<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>地雷识别</title>
      <link href="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/"/>
      <url>/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="地雷识别：">地雷识别：</h4><h5 id="一：进行特征提取与匹配获取黑色方框的位置：">一：进行特征提取与匹配获取黑色方框的位置：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">r&quot;C:\p\TZ1_No2.jpg&quot;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">img1 = cv2.imread(<span class="string">r&quot;C:\p\1.png&quot;</span>)</span><br><span class="line">img1_gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure><h5 id="1-将目标物体图片与需识别的图片转化为灰度图片，">1.将目标物体图片与需识别的图片转化为灰度图片，</h5><h5 id="2-注：特征提取有SIFT与ORB等多种方法。此处采用SIFT特征提取，">2.注：特征提取有SIFT与ORB等多种方法。此处采用SIFT特征提取，</h5><h5 id="SIFT有以下成员函数：">SIFT有以下成员函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.sift.create() <span class="comment">#创建sift类对象</span></span><br><span class="line">keypoints = cv2.sift.create().detect(image[,mask])<span class="comment">#检测图像中的sift关键点</span></span><br><span class="line">keypoints, descriptors = cv2.sift.compute(image, keypoints) <span class="comment">#计算出关键点构成的sift特征描述子</span></span><br><span class="line"><span class="comment">#也可以使用opencv提供的便捷绘制函数</span></span><br><span class="line">outimage = cv2.drawKeypoints(image,keypoint,outimage[,color[,flag]]) <span class="comment">#直接绘制出关键点之后的图像</span></span><br><span class="line"><span class="comment">#其中flags有多种参数可自行查阅自己所需的模式</span></span><br></pre></td></tr></table></figure><h5 id="3-进行特征匹配-主要采用两种匹配方式：暴力匹配与快速最近邻">3.进行特征匹配,主要采用两种匹配方式：暴力匹配与快速最近邻</h5><h5 id="暴力匹配：">暴力匹配：</h5><h5 id="创建BFMatcher类对象，有以下成员函数">创建BFMatcher类对象，有以下成员函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.BFMatcher() <span class="comment">#创建BFMatcher类</span></span><br><span class="line">matches = cv2.BFMatcher.<span class="keyword">match</span>(querydescriptors,traindescriptors[,masks]) <span class="comment">#querydescriptors:目标特征点集，traindescriptors:要匹配的点集，masks:指定两个特征点集间允许的匹配</span></span><br><span class="line">matches = cv2.BFMatcher.KnnMatch(querydescriptors,traindescriptors,k[,masks[,compactresult]])<span class="comment">#每个特征可以只找k个最佳的匹配的特征</span></span><br></pre></td></tr></table></figure><h5 id="匹配的特征也用opencv提供的函数绘制图像">匹配的特征也用opencv提供的函数绘制图像</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outimg = cv2.drawMatches(img1,keypoints,img2,keypoints,matches1to2,outimg[,matchcolor[,singlepointcolor[,matchesmask[,flags]]]]) <span class="comment">#matches1to2第一张图像特征点到第二张图像特征点的匹配，即keypoints1[i]匹配的特征点为keypoints2[matches1to2[i]]</span></span><br><span class="line"><span class="comment"># matchclolor:匹配的线和关键点的颜色</span></span><br><span class="line"><span class="comment">#flags:绘制的设定与cv2.drawkeypoints()中的flags取值一样</span></span><br></pre></td></tr></table></figure><h5 id="同时也会对匹配的特征进行筛选">同时也会对匹配的特征进行筛选</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m, n <span class="keyword">in</span> matches:</span><br><span class="line">    <span class="keyword">if</span> m.distance &lt; ratio_thresh * n.distance:</span><br><span class="line">        good_matches.append([m]) <span class="comment">#m与n有着匹配的关系</span></span><br></pre></td></tr></table></figure><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240908162512.png" alt="20240908162512"></p><h5 id="但经过实际测试发现使用暴力测试发生了较大的偏差，推测可能是因为图片的明显特征太少不易识别。下图采用特征点较多的图片发现匹配度还可以。">但经过实际测试发现使用暴力测试发生了较大的偏差，推测可能是因为图片的明显特征太少不易识别。下图采用特征点较多的图片发现匹配度还可以。</h5><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240908163153.png" alt="20240908163153"></p><h5 id="故而采用另一种匹配方式：快速最近邻（FLANN）">故而采用另一种匹配方式：快速最近邻（FLANN）</h5><h5 id="FLANN创建-FlannBasedMatcher-类对象，有以下图">FLANN创建 FlannBasedMatcher 类对象，有以下图</h5><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240908165658.png" alt="20240908165658"></p><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240908170316.png" alt="20240908170316"></p><h5 id="但对于这种简单的图片仍无法很好的识别！">但对于这种简单的图片仍无法很好的识别！</h5><h4 id="方法二：先进行仿射变换获取平整的图像，再进行模型匹配。">方法二：先进行仿射变换获取平整的图像，再进行模型匹配。</h4><h5 id="仿射变换：将图像进行线性变换和平移变换得到新图像的操作，保留了原始的平行性，长度比等等，opencv提供的函数：">仿射变换：将图像进行线性变换和平移变换得到新图像的操作，保留了原始的平行性，长度比等等，opencv提供的函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.warpAffine(src, M, dsize[,flags[,bordermode[,bordervalue]]]) </span><br><span class="line"><span class="comment"># src:输入图像，</span></span><br><span class="line"><span class="comment"># M:从src变换到dst的变换矩阵，</span></span><br><span class="line"><span class="comment"># dsize:输出图像的大小</span></span><br><span class="line"><span class="comment"># flags:默认为cv2.INTER_LINEAR,</span></span><br><span class="line"><span class="comment"># bordermode:默认值，</span></span><br><span class="line"><span class="comment"># bordervalue:默认值</span></span><br><span class="line"><span class="comment"># dst:输出图像，dst(x,y) = src(T),T此处为线性关系</span></span><br></pre></td></tr></table></figure><h5 id="通过各种操作得出M相对麻烦，而opencv库中也有一个函数可以直接得出M">通过各种操作得出M相对麻烦，而opencv库中也有一个函数可以直接得出M</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.getAffineTransform(src,dst)</span><br><span class="line"><span class="comment"># src:输入图像的坐标</span></span><br><span class="line"><span class="comment"># dst:输出图像的坐标</span></span><br><span class="line"><span class="comment"># 变换矩阵需要每个图像的三个坐标来算出M</span></span><br></pre></td></tr></table></figure><h5 id="若仿射变换只涉及缩放和旋转opencv还有专门的函数">若仿射变换只涉及缩放和旋转opencv还有专门的函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.getRotationMatrix2D(center,angle,scale)</span><br><span class="line"><span class="comment"># center:旋转中心</span></span><br><span class="line"><span class="comment"># angle:旋转角度，正数代表逆向旋转</span></span><br><span class="line"><span class="comment"># scale:缩放比例</span></span><br></pre></td></tr></table></figure><h5 id="现在最主要的问题在于寻找center-angle-而opencv中也用库函数可以解决：">现在最主要的问题在于寻找center,angle,而opencv中也用库函数可以解决：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rotatedrect = cv2.minAreaRect(inputarray points)</span><br><span class="line"><span class="comment"># points:点的集合，轮廓</span></span><br><span class="line"><span class="comment"># 其中rotatedrect包含(center(x,y),(width, height),angle of rotation)</span></span><br><span class="line"><span class="comment"># 而点集(轮廓)，通过边缘检测获得</span></span><br><span class="line">contours, hierarchy = cv2.findcontours(image, mode, method)</span><br><span class="line"><span class="comment"># image:获得的二值化图像</span></span><br><span class="line"><span class="comment"># mode:轮廓检索模式，RETR_TREE,从二值化图像中检索出所有可能的轮廓</span></span><br><span class="line"><span class="comment"># method:轮廓近似方法，使用CHAIN_APPROX_NONE</span></span><br><span class="line"><span class="comment"># contours:获得的轮廓（列表）列表里面的各个数组存储着各个轮廓的点集</span></span><br><span class="line"><span class="comment"># hierarchy: 层次关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制轮廓</span></span><br><span class="line">cv2.drawcontours(image, contours, contourldx, color, thickness)</span><br><span class="line"><span class="comment"># image:要在其上绘制轮廓的RGB图像</span></span><br><span class="line"><span class="comment"># contouldx: 轮廓点的像素坐标，可以从此列表中指定索引的位置从而指定绘制轮廓点，通常为-1绘制整个轮廓</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/09/07/hello-world/"/>
      <url>/2024/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
