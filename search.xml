<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>距离检测</title>
      <link href="/2024/09/11/%E8%B7%9D%E7%A6%BB%E6%A3%80%E6%B5%8B/"/>
      <url>/2024/09/11/%E8%B7%9D%E7%A6%BB%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h5 id></h5><h5 id="大概思路：">大概思路：</h5><h5 id="1-根据第一张图获取焦距的大小">1.根据第一张图获取焦距的大小</h5><h5 id="2-标记圆环的位置，算出距离并以文字输出">2.标记圆环的位置，算出距离并以文字输出</h5><h5 id="相似三角形：物体的实际宽度W，距离相机的位置D，拍照获取图片的像素宽度P（图像中圆环的宽度），有公式F-P-D-W">相似三角形：物体的实际宽度W，距离相机的位置D，拍照获取图片的像素宽度P（图像中圆环的宽度），有公式F=(P*D)/W</h5><h5 id="1-建立框架，需从文件中读取图像，并返回一个文件夹">1.建立框架，需从文件中读取图像，并返回一个文件夹</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">os.path.join() <span class="comment">#用于拼接文件路径，</span></span><br><span class="line"><span class="comment"># 如果没有&#x27;/&#x27;开头的参数</span></span><br><span class="line">os.path.join(<span class="string">&#x27;path&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出：path\abc\xyz</span></span><br><span class="line"><span class="comment">#如果存在‘/’开始的参数从最后一个以‘/’开头的参数开始拼接之前的全都舍弃</span></span><br><span class="line">os.path(<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;/bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出：/bbb\ccc</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = os.listdir(input_folder_path) <span class="comment">#可以返回指定文件夹下文件的列表通常是无序的可以采用内置函数sorted（）进行排序</span></span><br><span class="line">file.sort(key = <span class="keyword">lambda</span> x : <span class="built_in">int</span>(x[:-<span class="number">4</span>]))</span><br><span class="line"><span class="comment"># lamba函数作用：对输入的参数x进行处理</span></span><br><span class="line"><span class="comment"># int(x[:-4])表示去除字符串最后四个字符的部分并转换为整数，TZ2_No1.png ~ TZ2_No1 ~ 再转换为整数排序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>地雷识别</title>
      <link href="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/"/>
      <url>/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="地雷识别：">地雷识别：</h4><h5 id="一：进行特征提取与匹配获取黑色方框的位置：">一：进行特征提取与匹配获取黑色方框的位置：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">r&quot;C:\p\TZ1_No2.jpg&quot;</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">img1 = cv2.imread(<span class="string">r&quot;C:\p\1.png&quot;</span>)</span><br><span class="line">img1_gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure><h5 id="1-将目标物体图片与需识别的图片转化为灰度图片，">1.将目标物体图片与需识别的图片转化为灰度图片，</h5><h5 id="2-注：特征提取有SIFT与ORB等多种方法。此处采用SIFT特征提取，">2.注：特征提取有SIFT与ORB等多种方法。此处采用SIFT特征提取，</h5><h5 id="SIFT有以下成员函数：">SIFT有以下成员函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.sift.create() <span class="comment">#创建sift类对象</span></span><br><span class="line">keypoints = cv2.sift.create().detect(image[,mask])<span class="comment">#检测图像中的sift关键点</span></span><br><span class="line">keypoints, descriptors = cv2.sift.compute(image, keypoints) <span class="comment">#计算出关键点构成的sift特征描述子</span></span><br><span class="line"><span class="comment">#也可以使用opencv提供的便捷绘制函数</span></span><br><span class="line">outimage = cv2.drawKeypoints(image,keypoint,outimage[,color[,flag]]) <span class="comment">#直接绘制出关键点之后的图像</span></span><br><span class="line"><span class="comment">#其中flags有多种参数可自行查阅自己所需的模式</span></span><br></pre></td></tr></table></figure><h5 id="3-进行特征匹配-主要采用两种匹配方式：暴力匹配与快速最近邻">3.进行特征匹配,主要采用两种匹配方式：暴力匹配与快速最近邻</h5><h5 id="暴力匹配：">暴力匹配：</h5><h5 id="创建BFMatcher类对象，有以下成员函数">创建BFMatcher类对象，有以下成员函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.BFMatcher() <span class="comment">#创建BFMatcher类</span></span><br><span class="line">matches = cv2.BFMatcher.<span class="keyword">match</span>(querydescriptors,traindescriptors[,masks]) <span class="comment">#querydescriptors:目标特征点集，traindescriptors:要匹配的点集，masks:指定两个特征点集间允许的匹配</span></span><br><span class="line">matches = cv2.BFMatcher.KnnMatch(querydescriptors,traindescriptors,k[,masks[,compactresult]])<span class="comment">#每个特征可以只找k个最佳的匹配的特征</span></span><br></pre></td></tr></table></figure><h5 id="匹配的特征也用opencv提供的函数绘制图像">匹配的特征也用opencv提供的函数绘制图像</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outimg = cv2.drawMatches(img1,keypoints,img2,keypoints,matches1to2,outimg[,matchcolor[,singlepointcolor[,matchesmask[,flags]]]]) <span class="comment">#matches1to2第一张图像特征点到第二张图像特征点的匹配，即keypoints1[i]匹配的特征点为keypoints2[matches1to2[i]]</span></span><br><span class="line"><span class="comment"># matchclolor:匹配的线和关键点的颜色</span></span><br><span class="line"><span class="comment">#flags:绘制的设定与cv2.drawkeypoints()中的flags取值一样</span></span><br></pre></td></tr></table></figure><h5 id="同时也会对匹配的特征进行筛选">同时也会对匹配的特征进行筛选</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m, n <span class="keyword">in</span> matches:</span><br><span class="line">    <span class="keyword">if</span> m.distance &lt; ratio_thresh * n.distance:</span><br><span class="line">        good_matches.append([m]) <span class="comment">#m与n有着匹配的关系</span></span><br></pre></td></tr></table></figure><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240908162512.png" alt="20240908162512"></p><h5 id="但经过实际测试发现使用暴力测试发生了较大的偏差，推测可能是因为图片的明显特征太少不易识别。下图采用特征点较多的图片发现匹配度还可以。">但经过实际测试发现使用暴力测试发生了较大的偏差，推测可能是因为图片的明显特征太少不易识别。下图采用特征点较多的图片发现匹配度还可以。</h5><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240908163153.png" alt="20240908163153"></p><h5 id="故而采用另一种匹配方式：快速最近邻（FLANN）">故而采用另一种匹配方式：快速最近邻（FLANN）</h5><h5 id="FLANN创建-FlannBasedMatcher-类对象，有以下图">FLANN创建 FlannBasedMatcher 类对象，有以下图</h5><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240908165658.png" alt="20240908165658"></p><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240908170316.png" alt="20240908170316"></p><h5 id="但对于这种简单的图片仍无法很好的识别！">但对于这种简单的图片仍无法很好的识别！</h5><h4 id="方法二：先简单旋转再识别小方框再进行仿射变换获取平整的图像，再检测圆环输出坐标位置。">方法二：先简单旋转再识别小方框再进行仿射变换获取平整的图像，再检测圆环输出坐标位置。</h4><h5 id="20240911102240"><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240911102240.png" alt="20240911102240"></h5><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240911123250.png" alt="20240911123250"></p><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240911130013.png" alt="20240911130013"></p><h5 id="opencv中的面积函数：">opencv中的面积函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.contoursArea()</span><br></pre></td></tr></table></figure><h5 id="1-先进行简单的旋转使得图像相对横平竖直：">1.先进行简单的旋转使得图像相对横平竖直：</h5><h5 id="opencv库函数cv2-minArearect-返回角度的讨论：">opencv库函数cv2.minArearect()返回角度的讨论：</h5><h5 id="旋转角度angle-先选择一个点，这个点必须y最小，当y相等时x最小，然后从x轴开始旋转，遇到的第一个边为宽，angle为此时旋转的角度，第二个遇到的为高，其中可以通过宽和高的大小来更好的调整旋转角度">旋转角度angle:先选择一个点，这个点必须y最小，当y相等时x最小，然后从x轴开始旋转，遇到的第一个边为宽，angle为此时旋转的角度，第二个遇到的为高，其中可以通过宽和高的大小来更好的调整旋转角度</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rotatedrect[<span class="number">1</span>][<span class="number">0</span>] &gt; rotatedrect[<span class="number">1</span>][<span class="number">1</span>]: <span class="comment"># 宽大于高</span></span><br><span class="line">angle = rotatedrect[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    angle = -（<span class="number">90.0</span>-rect[<span class="number">2</span>]） <span class="comment"># 负号代表逆向旋转</span></span><br></pre></td></tr></table></figure><h5 id="20240909205142"><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240909205142.png" alt="20240909205142"></h5><h5 id="仿射变换：将图像进行线性变换和平移变换得到新图像的操作，保留了原始的平行性，长度比等等，opencv提供的函数：">仿射变换：将图像进行线性变换和平移变换得到新图像的操作，保留了原始的平行性，长度比等等，opencv提供的函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.warpAffine(src, M, dsize[,flags[,bordermode[,bordervalue]]]) </span><br><span class="line"><span class="comment"># src:输入图像，</span></span><br><span class="line"><span class="comment"># M:从src变换到dst的变换矩阵，</span></span><br><span class="line"><span class="comment"># dsize:输出图像的大小</span></span><br><span class="line"><span class="comment"># flags:默认为cv2.INTER_LINEAR,</span></span><br><span class="line"><span class="comment"># bordermode:默认值，</span></span><br><span class="line"><span class="comment"># bordervalue:默认值</span></span><br><span class="line"><span class="comment"># dst:输出图像，dst(x,y) = src(T),T此处为线性关系</span></span><br></pre></td></tr></table></figure><h5 id="通过各种操作得出M相对麻烦，而opencv库中也有一个函数可以直接得出M">通过各种操作得出M相对麻烦，而opencv库中也有一个函数可以直接得出M</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.getAffineTransform(src,dst)</span><br><span class="line"><span class="comment"># src:输入图像的坐标</span></span><br><span class="line"><span class="comment"># dst:输出图像的坐标</span></span><br><span class="line"><span class="comment"># 变换矩阵需要每个图像的三个坐标来算出M</span></span><br></pre></td></tr></table></figure><h5 id="若仿射变换只涉及缩放和旋转opencv还有专门的函数">若仿射变换只涉及缩放和旋转opencv还有专门的函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.getRotationMatrix2D(center,angle,scale)</span><br><span class="line"><span class="comment"># center:旋转中心</span></span><br><span class="line"><span class="comment"># angle:旋转角度，” 正数代表逆向旋转 “</span></span><br><span class="line"><span class="comment"># scale:缩放比例</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(center(x,y), (width, height), angle of rotation) = cv2.minAreaRect(points)</span><br><span class="line"><span class="comment"># 最小面积矩形框可以返回角度等供旋转矫正使用</span></span><br></pre></td></tr></table></figure><h5 id="python中的内置函数可以很好的解决轮廓大小的排序：">python中的内置函数可以很好的解决轮廓大小的排序：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new = <span class="built_in">sorted</span>(iterable, key, reverse)</span><br><span class="line"><span class="comment"># iterable:需要排序的对象，元组，列表，集合等</span></span><br><span class="line"><span class="comment"># key:指定一个函数用于生成排序的比较建，key = cv2.contoursArea,通过比较面积来排序</span></span><br><span class="line"><span class="comment"># reverse:一个布尔值，用于排序默认为flase为升序，true为降序</span></span><br></pre></td></tr></table></figure><h5 id="20240909201542"><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/20240909201542.png" alt="20240909201542"></h5><h5 id="2-再进行模板匹配，匹配出小黑方框：">2.再进行模板匹配，匹配出小黑方框：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = cv2.matchTemplate(image, templ, method)</span><br><span class="line"><span class="comment"># image: 大图像</span></span><br><span class="line"><span class="comment"># templ: 小图像模板</span></span><br><span class="line"><span class="comment"># method: 匹配算法：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;cv2.TM_CCOEFF:  相关系数</span></span><br><span class="line"><span class="string">cv2.TM_CCOEFF_NORMED： 相关系数</span></span><br><span class="line"><span class="string">cv2.TM_CCORR：相关性</span></span><br><span class="line"><span class="string">cv2.TM_CCORR_NORMED：相关性</span></span><br><span class="line"><span class="string">cv2.TM_SQDIFF：平方差</span></span><br><span class="line"><span class="string">cv2.TM_SQDIFF_NORMED:平方差 &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 返回值 result:是一个矩阵，其中每个元素表示模板在目标图像对应位置的匹配程度</span></span><br></pre></td></tr></table></figure><h5 id="3-匹配完之后就需要获取小黑方框的坐标">3.匹配完之后就需要获取小黑方框的坐标</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minval, maxval, minloc, maxloc = cv2.minmaxloc(result)</span><br><span class="line"><span class="comment"># minval:图像中的最小像素值</span></span><br><span class="line"><span class="comment"># maxval:图像中的最大像素值</span></span><br><span class="line"><span class="comment"># minloc:最小像素的位置（为两个元素的元组，表示横纵坐标）</span></span><br><span class="line"><span class="comment"># maxloc:最大像素值的位置</span></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line"><span class="comment"># result:为一个矩阵，通过此函数可以得到此矩阵的最小值，最大值，并得到最小值最大值的索引。</span></span><br></pre></td></tr></table></figure><h5 id="4-旋转使小黑方框位于右上角：">4.旋转使小黑方框位于右上角：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m = cv2.getRotationMatrix2D(center, <span class="number">90</span>, <span class="number">1.0</span>)</span><br><span class="line">m1 = cv2.getRotationMatrix2D(center, <span class="number">180</span>, <span class="number">1.0</span>)</span><br><span class="line">m2 = cv2.getRotationMatrix2D(center, -<span class="number">90</span>, <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">if</span> bottom_right[<span class="number">0</span>] &lt; center[<span class="number">0</span>] <span class="keyword">and</span> bottom_right[<span class="number">1</span>] &lt; center[<span class="number">1</span>]:</span><br><span class="line">    dst = cv2.warpAffine(dst, m, (h1, w1))</span><br><span class="line"><span class="keyword">elif</span> bottom_right[<span class="number">0</span>] &lt; center[<span class="number">0</span>] <span class="keyword">and</span> bottom_right[<span class="number">1</span>] &gt; center[<span class="number">1</span>]:</span><br><span class="line">    dst = cv2.warpAffine(dst, m1, (w1, h1))</span><br><span class="line"><span class="keyword">elif</span> bottom_right[<span class="number">0</span>] &gt; center[<span class="number">0</span>] <span class="keyword">and</span> bottom_right[<span class="number">1</span>] &gt; center[<span class="number">1</span>]:</span><br><span class="line">    dst = cv2.warpAffine(dst, m2, (h1, w1))</span><br></pre></td></tr></table></figure><h5 id="5-获取第二大矩形的角点，透视将图片置于二维平面上：">5.获取第二大矩形的角点，透视将图片置于二维平面上：</h5><h5 id="识别出它们是四边形通过多边形逼近使用opencv的库函数">识别出它们是四边形通过多边形逼近使用opencv的库函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">approxcurve = cv2.approxPolyDP(inputarray curve, double epsilom, <span class="built_in">bool</span> closed)</span><br><span class="line"><span class="comment"># curve:输入的轮廓点集</span></span><br><span class="line"><span class="comment"># approxcurve:输出拟合的多边形点集，</span></span><br><span class="line"><span class="comment"># epsilon:近似图像的精度，原始图像与它的近似之间的最大距离</span></span><br><span class="line"><span class="comment"># closed: 如果为true，则图像为闭合曲线，反之不闭合</span></span><br></pre></td></tr></table></figure><h5 id="python中的内置函数">python中的内置函数:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(start, stop,[,step])</span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>) <span class="comment"># 输出：0，1，2，3，4    左开右闭生成一个整数序列</span></span><br><span class="line"><span class="comment"># 接受的参数必须为整数，可以是负数，不能为浮点数等</span></span><br><span class="line"><span class="comment"># 它是不可变的序列类型，可以进行判断元素，查找元素，切片等操作，但不能修改元素</span></span><br><span class="line"><span class="keyword">for</span> i  <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">8</span>, -<span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"> <span class="comment"># 输出:-8,-6,-4</span></span><br></pre></td></tr></table></figure><h5 id></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rotatedrect = cv2.minAreaRect(inputarray points)</span><br><span class="line"><span class="comment"># points:点的集合，轮廓</span></span><br><span class="line"><span class="comment"># 其中rotatedrect包含(center(x,y),(width, height),angle of rotation)</span></span><br><span class="line"><span class="comment"># 而点集(轮廓)，通过边缘检测获得</span></span><br><span class="line">contours, hierarchy = cv2.findcontours(image, mode, method)</span><br><span class="line"><span class="comment"># image:获得的二值化图像</span></span><br><span class="line"><span class="comment"># mode:轮廓检索模式，RETR_TREE,从二值化图像中检索出所有可能的轮廓</span></span><br><span class="line"><span class="comment"># method:轮廓近似方法，使用CHAIN_APPROX_NONE</span></span><br><span class="line"><span class="comment"># contours:获得的轮廓（列表）列表里面的各个数组存储着各个轮廓的点集</span></span><br><span class="line"><span class="comment"># hierarchy: 层次关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制轮廓</span></span><br><span class="line">cv2.drawcontours(image, contours, contourldx, color, thickness)</span><br><span class="line"><span class="comment"># image:要在其上绘制轮廓的RGB图像</span></span><br><span class="line"><span class="comment"># contouldx: 轮廓点的像素坐标，可以从此列表中指定索引的位置从而指定绘制轮廓点，通常为-1绘制整个轮廓</span></span><br></pre></td></tr></table></figure><h5 id="三维变二维：8">三维变二维：<img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/8.png" alt="8"></h5><p><img src="/2024/09/07/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB/9.jpeg" alt="9"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.warpperspective(src, M, dsize, flags, borderMode, bordervalue) <span class="comment"># 通过此函数实现透视效果</span></span><br><span class="line"><span class="comment"># dsize；输出图像的尺寸，flags,borderMode, bordervalue,推荐使用默认值</span></span><br><span class="line">M = cv2.getperspectivetransform(src, dst)</span><br><span class="line"><span class="comment"># src:输入图像的四个坐标</span></span><br><span class="line"><span class="comment"># dst:输出图像的四个坐标</span></span><br></pre></td></tr></table></figure><h6 id="6-进行霍夫圆的检测获取圆心坐标进而输出A-F-1-4的坐标">6.进行霍夫圆的检测获取圆心坐标进而输出A-F,1-4的坐标</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">circles = cv2.HoughCircles(image, method, dp, minDist, param1,param2,minRadius,maxRadius)</span><br><span class="line"><span class="comment"># image :检测的原图像</span></span><br><span class="line"><span class="comment"># method：仅有一个值：cv2.HOUGH_GRADIENT</span></span><br><span class="line"><span class="comment"># dp:累加器与原图像的分辨率之比，</span></span><br><span class="line"><span class="comment"># minDist:圆心之间的最小距离</span></span><br><span class="line"><span class="comment"># param1:Canny边缘检测的阈值</span></span><br><span class="line"><span class="comment"># param2:检测圆环的投票数，数越高越精准</span></span><br><span class="line"><span class="comment"># minRadius: 圆环的最小半径</span></span><br><span class="line"><span class="comment"># minRadius: 圆环的最大半径</span></span><br><span class="line"><span class="comment"># circles: 为一个数组存储圆心坐标与半径[[[x1,y1,r1],[x2,y2,r2]]]</span></span><br></pre></td></tr></table></figure><p><video src="./C:/Users/xzh/Desktop/%E5%9C%B0%E9%9B%B7%E8%AF%86%E5%88%AB2.mp4"></video></p><h5 id="经过实际的使用发现任然不能完美的检测（1-10的错误率），其中可能是因为那两张图三维的角度上转的比较离谱导致模板没有匹配的上或者多边形逼近获得的角点坐标错误">经过实际的使用发现任然不能完美的检测（1/10的错误率），其中可能是因为那两张图三维的角度上转的比较离谱导致模板没有匹配的上或者多边形逼近获得的角点坐标错误</h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/09/07/hello-world/"/>
      <url>/2024/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
